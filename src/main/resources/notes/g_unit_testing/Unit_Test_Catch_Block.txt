Writing unit tests to **cover `catch` blocks** is important for ensuring your code behaves correctly when **exceptions occur**. Here's how to approach it.

---

## âœ… Goal

You want to **simulate an exception** in a dependency, so your code enters the `catch` block, and then **assert what happens inside it** (e.g., logging, default values, custom exceptions, etc.).

---

## ðŸ”§ Strategy

1. **Mock a method to throw an exception**
2. **Call the method under test**
3. **Assert the behavior inside the `catch` block** (e.g., log captured, fallback value returned, exception rethrown, etc.)

---

## ðŸŽ¯ Example

Letâ€™s say you have the following service:

```java
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    public User getUserById(Long id) {
        try {
            return userRepository.findById(id).orElseThrow(() -> new RuntimeException("User not found"));
        } catch (Exception e) {
            // Catch block logic
            System.err.println("Exception occurred: " + e.getMessage());
            return null; // or throw new CustomException(...)
        }
    }
}
```

---

## ðŸ§ª Unit Test to Cover `catch` Block

```java
@RunWith(MockitoJUnitRunner.class)
public class UserServiceTest {

    @Mock
    private UserRepository userRepository;

    @InjectMocks
    private UserService userService;

    @Test
    public void testGetUserById_exceptionCaught_returnsNull() {
        // Arrange: simulate an exception
        Mockito.when(userRepository.findById(1L)).thenThrow(new RuntimeException("DB failure"));

        // Act: call method that should enter catch block
        User result = userService.getUserById(1L);

        // Assert: validate catch block behavior
        assertNull(result);  // You could also verify log or error response
    }
}
```

---

## ðŸ§  Things You Can Assert Inside Catch Block

Depending on your actual logic inside the `catch`, you might:

* âœ… Assert returned value (`null`, default, fallback, etc.)
* âœ… Assert a custom exception is thrown
* âœ… Use a logger and verify that log was called (with LogCaptor or a mocking library)
* âœ… Ensure program doesnâ€™t crash (graceful failure)

---

## ðŸ’¡ Extra Tip (for exception assertions)

If your catch block **rethrows a custom exception**, test like this:

```java
@Test
public void testGetUserById_exceptionThrown_rethrowsCustomException() {
    Mockito.when(userRepository.findById(1L))
           .thenThrow(new RuntimeException("DB down"));

    assertThrows(CustomServiceException.class, () -> {
        userService.getUserById(1L);
    });
}
```

---

## ðŸ§ª Tools to Help You Test Catch Blocks

* **Mockito `thenThrow(...)`**
* **JUnit `assertThrows(...)`**
* **AssertJ or Hamcrest** for expressive assertions
* **LogCaptor** (optional) to test logging behavior inside `catch`

---

## âœ… Summary

| Goal                     | How to Achieve                               |
| ------------------------ | -------------------------------------------- |
| Enter catch block        | Mock dependency to throw exception           |
| Return fallback or null  | Assert return value is correct               |
| Rethrow custom exception | Use `assertThrows()`                         |
| Verify logging           | Use a logger-capturing tool like `LogCaptor` |

Let me know if youâ€™d like a Spring Bootâ€“based version of this with real controller or service examples.
